declare const pdfjsLib: any;
declare const JSZip: any;

const stripTags = (text: string): string => {
  return text.replace(/<[^>]*>?/gm, ' ').replace(/\s+/g, ' ').trim();
};

const parseFB2String = (text: string): string => {
  const parser = new DOMParser();
  const xmlDoc = parser.parseFromString(text, "text/xml");
  
  // Try standard FB2 body
  let bodies: HTMLCollectionOf<Element> = xmlDoc.getElementsByTagName("body");
  
  // Fallback for namespaced body (e.g. <fb:body>)
  if (bodies.length === 0) {
    bodies = xmlDoc.getElementsByTagNameNS("*", "body");
  }

  let fullText = "";
  
  if (bodies.length > 0) {
      for (let i = 0; i < bodies.length; i++) {
        fullText += bodies[i].textContent || "";
      }
  } else {
      // Last resort: just dump all text content from the root
      fullText = xmlDoc.documentElement.textContent || "";
  }
  
  // If parsing failed (empty), try raw regex strip (in case of really broken XML)
  if (fullText.trim().length === 0) {
      return stripTags(text);
  }
  
  return stripTags(fullText);
};

export const parseFile = async (file: File): Promise<string> => {
  const fileType = file.name.split('.').pop()?.toLowerCase();
  
  try {
    if (fileType === 'zip') {
      return await parseZip(file);
    } else if (fileType === 'pdf') {
      return await parsePDF(file);
    } else if (['fb2', 'xml'].includes(fileType || '')) {
      return await parseFB2(file);
    } else if (['txt', 'md'].includes(fileType || '')) {
      return await file.text();
    } else {
      throw new Error(`Format .${fileType} is not supported. Use ZIP, PDF, FB2, TXT, or MD.`);
    }
  } catch (error: any) {
    console.error("File parsing error:", error);
    throw new Error(error.message || `Failed to parse ${fileType?.toUpperCase()} file.`);
  }
};

const parseZip = async (file: File): Promise<string> => {
  const zip = new JSZip();
  const content = await zip.loadAsync(file);
  const files = Object.keys(content.files);

  // Priority order for files inside zip
  const extensions = ['fb2', 'pdf', 'txt', 'md', 'xml'];
  
  let targetFile: string | null = null;
  
  // Find first matching file
  for (const ext of extensions) {
    targetFile = files.find(name => name.toLowerCase().endsWith(`.${ext}`) && !name.startsWith('__MACOSX')) || null;
    if (targetFile) break;
  }

  if (!targetFile) {
     throw new Error("No supported files (PDF, FB2, TXT, MD) found in ZIP archive.");
  }

  console.log(`Found ${targetFile} inside zip.`);
  const fileEntry = content.files[targetFile];
  const blob = await fileEntry.async("blob");
  
  // Recursively call parseFile with the extracted file
  // We recreate a File object from the blob
  const extractedFile = new File([blob], targetFile, { type: blob.type });
  return parseFile(extractedFile);
};

const parsePDF = async (file: File): Promise<string> => {
  const arrayBuffer = await file.arrayBuffer();
  const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
  let fullText = '';

  for (let i = 1; i <= pdf.numPages; i++) {
    const page = await pdf.getPage(i);
    const textContent = await page.getTextContent();
    
    // Improved logic: respect hasEOL (End Of Line) to preserve paragraphs
    const pageText = textContent.items.map((item: any) => {
      return item.str + (item.hasEOL ? '\n' : ' ');
    }).join('');
    
    // Add double newline between pages to separate context clearly
    fullText += pageText + '\n\n';
  }
  
  // Cleanup excessive multiple spaces/newlines generated by PDF structure artifacts
  return fullText.replace(/  +/g, ' ').replace(/\n\s*\n/g, '\n\n').trim();
};

const parseFB2 = async (file: File): Promise<string> => {
  const text = await file.text();
  return parseFB2String(text); 
};